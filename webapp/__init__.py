# возвращаем в веб-приложении HTML вместо строки
from flask import Flask, render_template
from webapp.model import db, News
# from webapp.python_news import get_python_news
from webapp.weather import weather_by_city


def create_app():
    app = Flask(__name__)                # создаю Flask-приложение
    app.config.from_pyfile('config.py')  # указываю, откуда брать константы
    db.init_app(app)                     # инициализируем БД ПОСЛЕ config.py, т к в config.py лежит url
    @app.route('/')
    def index():
        title = 'Новости Python'        # переменная, которую мы вставляем в шаблон
        weather = weather_by_city(app.config['WEATHER_DEFAULT_CITY'])   # ('Moscow,Russia') - более ранний вариант
        # указания на город, до config.py Вытаскиваем константу "город" так же, как значение ключа словаря
        # news_list = get_python_news()  # вызываем функцию из парсера новостей (раняя редакция)
        news_list = News.query.order_by(News.published.desc()).all() # делаю Выборку Всех новостей -> располагаю По Порядку (от Свежей к старой)
        return render_template('index.html', page_title=title, weather=weather, news_list=news_list)
        # news_list - шаблон новостей для функции. В render_template передаем название файла
        # с шаблоном в кавычках + другие аргументы
    return app  # функция create_app возвращает Flask application

# if __name__ == "__main__":   эта часть нужна была до введения функции create_app()
#     app.run(debug=True)

# возвращаем f-строку. Внутри f-строки подразумевается html-разметка, которая хранится в отдельном файле index.html
# в папке templates (см подробнее templates_intro.html, index.html)
# совмещенная версия "код+разметка в 1 файле" выглядит так: return f""" <html....> """
# (Тройные кавычки означают, что по ходу текста будет перенос строк)
# если разметка осталась  внутри основного файла, переменные заключаем в ОДИНАРНЫЕ фигурн. скобки: { variable }
#  (ex:  <h1>{weather_text}</h1>  )
# функция render_template импортируется из flask -> в return (вместо html-разметки) закладываем эту функцию, внутрь
# функции передаем название файла с шаблоном в кавычках (index.html). Название папки, где лежит разметка,
# указывать не надо (движок по умолчанию обращается к папке templates)

# КОД про условия, который мы ПЕРЕНЕСЛИ В ФАЙЛ ШАБЛОНА (в шаблоне переменная weather_text пропадает за ненадобностью):
#    if weather:
#        weather_text = f"Сейчас: {weather['temp_C']}, ощущается как: {weather['FeelsLikeC']}" # кладем в переменную тот
                                                                        # текст, который мы хотим отдавать пользователю
#    else:
#        weather_text = 'Сервис погоды временно недоступен'

# импорт файла из конкретной директории - через точку (название головной директории -> нужной дир-рии -> название файла)
# ex: from web_track.webapp.python_news import get_python_news
# файлы __init__.py автоматически выполняются при импорте модуля. Если в папке создать файл __init__.py, она
# автоматически становится модулем Питона. При 'import webapp' файл __init__.py выполнится полностью, кроме
# строк if __name__ == "__main__"...
# Улучшение инициализации приложения через подход "фабрика". В нашем случае это функция, которая создает Flask app,
# проводит работу по инициализации и возвращает объект app. Этот подход позволит упаковать всю работу по инициализации
# приложения внутрь функции. Все, что есть в __init__ оборачиваем в функцию def create_app()
# процедура запуска приложения теперь такая: $ export FLASK_APP=webapp && export FLASK_ENV=development && flask run
#  т е с применением т н "переменного" окружения: отсылаем на папку webapp, запуск делаем в режиме
# "для разработчика". Все это параметры для выполнения команды 'flask run'. Я говорю "выполни последовательно 3 команды"
# (перечисляю их через двойной амперсанд - &&, вместо того, чтобы выполнять команды по 1 на каждой строке)
